import os
import sys
from StringIO import StringIO
from lxml import etree
from tempfile import mkstemp
import subprocess

INKSCAPE_BIN = '/Applications/Inkscape.app/Contents/Resources/bin/inkscape'
if not os.path.isfile(INKSCAPE_BIN):
  INKSCAPE_BIN = 'inkscape'

try:
  import pkg_resources
  resource_filename = pkg_resources.resource_filename
except ImportError:
  def resource_filename(dir, file):
    return os.path.join(os.getcwd(), dir, file)

INKSCAPE_BIN = '/Applications/Inkscape.app/Contents/Resources/bin/inkscape'
if not os.path.isfile(INKSCAPE_BIN):
  INKSCAPE_BIN = 'inkscape'



# http://lxml.de/xpathxslt.html
def makeXsl(filename):
  """ Helper that creates a XSLT stylesheet """
  path = resource_filename("xsl", filename)
  #print "Loading resource: %s" % path
  xml = etree.parse(path)
  return etree.XSLT(xml)

COLLXML_PARAMS = makeXsl('collxml-params.xsl')
COLLXML2DOCBOOK_XSL = makeXsl('collxml2dbk.xsl')

DOCBOOK_CLEANUP_XSL = makeXsl('dbk-clean-whole.xsl')
DOCBOOK_NORMALIZE_PATHS_XSL = makeXsl('dbk2epub-normalize-paths.xsl')
DOCBOOK_NORMALIZE_GLOSSARY_XSL = makeXsl('dbk-clean-whole-remove-duplicate-glossentry.xsl')



NAMESPACES = {
  'c'  :'http://cnx.rice.edu/cnxml',
  'svg':'http://www.w3.org/2000/svg',
  'mml':'http://www.w3.org/1998/Math/MathML',
  'db' :'http://docbook.org/ns/docbook',
  'xi' :'http://www.w3.org/2001/XInclude',
  'col':'http://cnx.rice.edu/collxml'}


# For SVG Cover image
DBK2SVG_COVER_XSL = makeXsl('dbk2svg-cover.xsl')
COLLECTION_COVER_PREFIX='_collection_cover'


# Used for loading collection/module from the filesystem
MODULES_XPATH = etree.XPath('//col:module/@document', namespaces=NAMESPACES)
IMAGES_XPATH = etree.XPath('//c:*/@src[not(starts-with(.,"http:"))]', namespaces=NAMESPACES)


# From http://stackoverflow.com/questions/2932408/
def svg2png(svgStr):
  fd, pngPath = mkstemp(suffix='.png')
  # Can't just use stdout because Inkscape outputs text to stdout _and_ stderr
  strCmd = [INKSCAPE_BIN, '--without-gui', '-f', '/dev/stdin', '--export-png=%s' % pngPath]
  p = subprocess.Popen(strCmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True)
  strOut, strError = p.communicate(svgStr)
  pngFile = open(pngPath)
  pngData = pngFile.read()
  pngFile.close()
  os.close(fd)
  os.remove(pngPath)
  return pngData

def dbk2cover(dbk, filesDict):
  newFiles = {}
  if ('%s.png' % COLLECTION_COVER_PREFIX) in filesDict:
    return filesDict['%s.png' % COLLECTION_COVER_PREFIX], newFiles
  
  if ('%s.svg' % COLLECTION_COVER_PREFIX) in filesDict:
    svgStr = filesDict['%s.svg' % COLLECTION_COVER_PREFIX]
  else:
    svg = transform(DBK2SVG_COVER_XSL, dbk)
    svgStr = etree.tostring(svg)
  
  newFiles['cover.svg'] = svgStr
  
  png = svg2png(svgStr)
  return png, newFiles

def transform(xslDoc, xmlDoc):
  """ Performs an XSLT transform and parses the <xsl:message /> text """
  ret = xslDoc(xmlDoc)
  for entry in xslDoc.error_log:
    # TODO: Log the errors (and convert JSON to python) instead of just printing
    print entry
  return ret


### The following are methods that load up files on the filesysteme into memory

def loadModule(moduleDir):
  """ Given a directory of files (containing an index.cnxml) 
      load it into memory """
  # Try autogenerated CNXML 1st
  cnxmlPath = os.path.join(moduleDir, 'index_auto_generated.cnxml')
  if not os.path.exists(cnxmlPath):
    cnxmlPath = os.path.join(moduleDir, 'index.cnxml')
  cnxmlStr = open(cnxmlPath).read()
  cnxml = etree.parse(StringIO(cnxmlStr))
  files = {}
  for f in IMAGES_XPATH(cnxml):
    try:
      data = open(os.path.join(moduleDir, f)).read()
      files[f] = data
      #print >> sys.stderr, "LOG: Image ADDED! %s %s" % (module, f)
    except IOError:
      print >> sys.stderr, "LOG: Image not found %s %s" % (os.path.basename(moduleDir), f)
  # If the dbk file has already been generated, include it
  dbkPath = os.path.join(moduleDir, 'index.included.dbk')
  if os.path.exists(dbkPath):
    dbkStr = open(dbkPath).read()
    files['index.included.dbk'] = dbkStr
  return (cnxml, files)


def loadCollection(dir):
  collxml = etree.parse(os.path.join(dir, 'collection.xml'))
  
  moduleIds = MODULES_XPATH(collxml)
  
  modules = {} # {'m1000': (etree.Element, {'file.jpg':'23947239874'})}
  allFiles = {}
  for moduleId in moduleIds:
    print >> sys.stderr, "LOG: Starting on %s" % (moduleId)
    moduleDir = os.path.join(dir, moduleId)
    if os.path.isdir(moduleDir):
      cnxml, files = loadModule(moduleDir)
      for f in files:
        allFiles[os.path.join(moduleId, f)] = files[f]

      modules[moduleId] = (cnxml, files)

  return collxml, modules, allFiles
